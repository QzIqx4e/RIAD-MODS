<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI System Prediction - RIAD MODS</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables for easy color change */
        :root {
            --main-bg: #f5f5f5;
            --primary-color: #512da8; /* Deep Purple */
            --secondary-color: #00bcd4; /* Cyan/Teal */
            --card-bg: #ffffff;
            --text-color: #333333;
            --danger-color: #e53935; /* Red */
            --success-color: #43a047; /* Green */
            --violet-color: #9c27b0;
        }

        /* Base Styles */
        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--main-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* Header */
        .header {
            width: 100%;
            padding: 15px 0;
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            margin: 0;
            font-size: 1.8em;
            font-weight: 900;
            letter-spacing: 1px;
        }

        /* Main Container */
        .container {
            width: 95%;
            max-width: 450px;
            padding: 20px 10px;
        }

        /* Info Cards */
        .info-cards {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 20px;
        }

        .info-card {
            background-color: var(--card-bg);
            padding: 15px;
            border-radius: 10px;
            flex: 1;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-bottom: 3px solid var(--secondary-color);
        }

        .card-title {
            color: #777;
            font-size: 0.8em;
            font-weight: 700;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .card-value {
            font-size: 1.6em;
            font-weight: 900;
            color: var(--text-color);
        }

        .period-value {
            color: var(--primary-color);
            font-size: 1.4em;
        }

        /* AI Prediction Card */
        .prediction-card {
            background: linear-gradient(145deg, var(--primary-color) 0%, #7e57c2 100%);
            padding: 30px 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 25px;
            color: white;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .ai-title {
            font-size: 1.4em;
            font-weight: 700;
            margin-bottom: 15px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .predicted-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 25px;
        }

        .predicted-number-circle {
            background-color: white;
            color: var(--primary-color);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            font-weight: 900;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .predicted-color-box {
            font-size: 1.2em;
            font-weight: 700;
            padding: 12px 25px;
            border-radius: 8px;
            min-width: 90px;
            text-align: center;
            color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        /* Dynamic Color Classes for Prediction */
        .c-red { background-color: var(--danger-color); }
        .c-green { background-color: var(--success-color); }
        .c-violet { background-color: var(--violet-color); }
        .c-red-violet { background: linear-gradient(to right, var(--danger-color) 50%, var(--violet-color) 50%); }
        .c-green-violet { background: linear-gradient(to right, var(--success-color) 50%, var(--violet-color) 50%); }


        /* Countdown */
        .countdown-section {
            text-align: center;
            margin-bottom: 25px;
        }

        .countdown-section p {
            font-size: 1.1em;
            font-weight: 700;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .countdown-timer {
            font-size: 3em;
            font-weight: 900;
            color: var(--secondary-color);
            letter-spacing: 2px;
        }
        .countdown-red {
            color: var(--danger-color) !important;
        }

        /* Refresh Button & Timestamp */
        .action-area {
            text-align: center;
        }

        .refresh-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 30px;
            font-size: 1.1em;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 6px 15px rgba(0, 188, 212, 0.5);
            transition: background-color 0.3s, transform 0.1s;
            text-transform: uppercase;
        }

        .refresh-btn:hover {
            background-color: #0097a7;
            transform: translateY(-2px);
        }

        .last-updated {
            margin-top: 20px;
            color: #999;
            font-size: 0.85em;
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>RIAD MODS AI SYSTEM PREDICTION ñ§ç</h1>
    </div>

    <div class="container">
        
        <div class="info-cards">
            <div class="info-card">
                <div class="card-title">Actual Result</div>
                <div class="card-value" id="actual-result-number">--</div>
            </div>
            <div class="info-card">
                <div class="card-title">Next Period</div>
                <div class="card-value period-value" id="current-period">0000</div>
            </div>
        </div>

        <div class="prediction-card">
            <div class="ai-title">ACCURATE AI PREDICTION</div>
            <div class="predicted-display">
                <div class="predicted-number-circle" id="predicted-number">?</div>
                <div class="predicted-color-box c-red" id="predicted-color">RED</div>
            </div>
        </div>

        <div class="countdown-section">
            <p>Next Result In:</p>
            <div class="countdown-timer" id="countdown-timer">00:00</div>
        </div>
        
        <div class="action-area">
            <button class="refresh-btn" id="refresh-btn">
                <span id="refresh-text">ANALYZE & REFRESH</span>
            </button>
            <div class="last-updated" id="last-updated-time">Last updated: --:--:--</div>
        </div>

    </div>

    <script>
        // DOM Elements Mapping
        const elements = {
            actualResultNumber: document.getElementById('actual-result-number'),
            currentPeriod: document.getElementById('current-period'),
            predictedNumber: document.getElementById('predicted-number'),
            predictedColor: document.getElementById('predicted-color'),
            countdownTimer: document.getElementById('countdown-timer'),
            refreshBtn: document.getElementById('refresh-btn'),
            lastUpdatedTime: document.getElementById('last-updated-time'),
        };

        // State & Configuration
        let lastFetchedPeriod = '202509280000'; // Initial mock/fallback period
        const TOTAL_COUNTDOWN = 60; // 1 minute cycle
        const RED_ALERT_TIME = 10;
        let countdown = TOTAL_COUNTDOWN;
        let countdownInterval = null;
        const API_URL = 'https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json';


        // --- Core Logic Functions ---

        /**
         * Safely adds one to a BigInt string to get the next period number.
         * @param {string} numStr The current period number string.
         * @returns {string} The next period number string.
         */
        function addOneToBigNumber(numStr) {
            try {
                // Use BigInt for accurate large number addition
                return (BigInt(numStr) + 1n).toString();
            } catch (e) {
                // Fallback for environments that don't fully support BigInt (unlikely in modern browsers)
                let carry = 1;
                let result = "";
                for (let i = numStr.length - 1; i >= 0; i--) {
                    const sum = parseInt(numStr[i]) + carry;
                    carry = Math.floor(sum / 10);
                    result = (sum % 10).toString() + result;
                }
                if (carry > 0) result = carry.toString() + result;
                return result.padStart(numStr.length, '0');
            }
        }


        /**
         * ü§ñ AI-Based Prediction Logic Simulation:
         * Generates a predicted result (number and color) based on the *next* period number.
         * @param {string} nextPeriod The period number to predict for.
         * @returns {{number: string, color: string, colorClass: string}} The prediction result.
         */
        function runAIPrediction(nextPeriod) {
            // Get the last four digits for simpler trending analysis
            const lastDigits = nextPeriod.slice(-4); 
            
            // Sum of digits for an "internal signal"
            const sumOfDigits = lastDigits.split('').reduce((sum, digit) => sum + parseInt(digit), 0);
            
            let predictedNumber;
            let predictedColor;
            let colorClass;

            // Simple Logic 1: Use a number based on the sum of digits
            predictedNumber = (sumOfDigits % 10).toString();

            // Simple Logic 2: Determine color based on the predicted number
            if (predictedNumber === '0' || predictedNumber === '5') {
                // Number 0 is Red/Violet, Number 5 is Green/Violet
                predictedColor = (predictedNumber === '0') ? "RED/VIOLET" : "GREEN/VIOLET";
                colorClass = (predictedNumber === '0') ? "c-red-violet" : "c-green-violet";
            } else if (parseInt(predictedNumber) % 2 === 0) {
                // Even numbers (2, 4, 6, 8) are Red
                predictedColor = "RED";
                colorClass = "c-red";
            } else {
                // Odd numbers (1, 3, 7, 9) are Green
                predictedColor = "GREEN";
                colorClass = "c-green";
            }

            // Logic 3: Introduce a "High Confidence Override" (e.g., if sum is prime)
            if (sumOfDigits === 11 || sumOfDigits === 13) {
                 predictedNumber = '2'; 
                 predictedColor = "RED";
                 colorClass = "c-red";
            }
            
            return {
                number: predictedNumber,
                color: predictedColor,
                colorClass: colorClass
            };
        }

        /**
         * Function to generate mock game result data for testing or fallback scenarios
         */
        function fetchMockGameResult() {
            // Simulate incrementing issue number for uniqueness to ensure new periods are always generated
            const mockIssueNumber = lastFetchedPeriod ? addOneToBigNumber(lastFetchedPeriod) : '202509280001';
            const mockNumber = Math.floor(Math.random() * 10); // Random number between 0-9
            console.warn("Using mock data for game result (API/Network/CORS issue).");
            return {
                issueNumber: mockIssueNumber,
                number: mockNumber.toString(),
                openTime: new Date().toLocaleTimeString(),
            };
        }

        /**
         * Fetches game results from the NEW API or falls back to mock data on error/empty response
         */
        async function fetchGameResult() {
            try {
                const timestamp = Date.now();
                const response = await fetch(`${API_URL}?ts=${timestamp}`);
                const data = await response.json();
                
                // Check if data or data.list is missing/empty, then fall back to mock data
                if (!data?.data?.list || data.data.list.length === 0) {
                    return fetchMockGameResult();
                }
                
                // The API call returns the list of past results. We want the most recent *actual* result.
                const mostRecentResult = data.data.list[0];
                console.log("Successfully fetched API data.", mostRecentResult);
                return mostRecentResult; // Return the most recent game result
            } catch (e) {
                console.error('API error (likely CORS/network issue):', e);
                // Fallback to mock data if fetch operation fails 
                return fetchMockGameResult();
            }
        }


        // --- UI Update & Fetch Functions ---

        /**
         * Updates the display with the new actual result and the AI's prediction for the next period.
         * @param {object} result The most recent game result object from the API/Mock.
         */
        function updateDisplay(result) {
            // 1. Update Actual Result 
            elements.actualResultNumber.textContent = result.number || '--';
            lastFetchedPeriod = result.issueNumber;

            // 2. Calculate Next Period and run prediction
            const nextPeriod = addOneToBigNumber(lastFetchedPeriod);
            const prediction = runAIPrediction(nextPeriod);

            // 3. Update Period and Prediction
            elements.currentPeriod.textContent = nextPeriod.slice(-4); // Show only the last 4 digits for clean UI
            elements.predictedNumber.textContent = prediction.number;
            elements.predictedColor.textContent = prediction.color;
            
            // 4. Clear and apply new color class
            elements.predictedColor.className = 'predicted-color-box ' + prediction.colorClass;

            // 5. Update Last Updated Time
            const now = new Date();
            elements.lastUpdatedTime.textContent = 'Last updated: ' + now.toLocaleTimeString('en-US', { hour12: false });
        }
        
        /**
         * Simulates the full data fetch/refresh cycle.
         */
        async function fetchData() {
            elements.refreshBtn.disabled = true;
            elements.refreshBtn.textContent = 'ANALYZING...';
            
            const result = await fetchGameResult();
            
            updateDisplay(result);

            // Reset and start countdown
            startCountdown();
            
            elements.refreshBtn.disabled = false;
            elements.refreshBtn.textContent = 'ANALYZE & REFRESH';
        }

        // Countdown Timer Logic
        function updateTimerDisplay() {
            const minutes = Math.floor(countdown / 60);
            const seconds = countdown % 60;
            elements.countdownTimer.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            // Apply visual feedback for low time
            if (countdown <= RED_ALERT_TIME) {
                elements.countdownTimer.classList.add('countdown-red');
            } else {
                elements.countdownTimer.classList.remove('countdown-red');
            }
        }

        function startCountdown() {
            clearInterval(countdownInterval);
            countdown = TOTAL_COUNTDOWN; 
            updateTimerDisplay();

            countdownInterval = setInterval(() => {
                countdown--;
                updateTimerDisplay();

                if (countdown < 0) {
                    // Time's up! Fetch new data
                    fetchData();
                }
            }, 1000);
        }

        // Initialization
        function init() {
            // Set up event listeners
            elements.refreshBtn.addEventListener('click', fetchData);
            
            // Initial fetch to populate the data
            fetchData();
        }

        // Start the application when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>!